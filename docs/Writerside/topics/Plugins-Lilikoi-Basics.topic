<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://helpserver.labs.jb.gg/help/schemas/mvp/html-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://helpserver.labs.jb.gg/help/schemas/mvp/topic.v2.xsd"
       title="Basics" id="Plugins-Lilikoi-Basics">

    <link-summary>
        BitMod uses Lilikoi under the hood to deliver consistent, dynamic,
        and performant contracts between plugins.
    </link-summary>

    <p>
        BitMod plugins use <a href="https://github.com/Mooshua/Lilikoi">Lilikoi</a> under the hood
        to provide a consistent API surface for event handlers. Lilikoi containers are used
        for their performance and rich extensibility. You don't really need to know much about how
        they work to write plugins, but it's always good to know what you're working with.
    </p>

    <p>
        Very few BitMod features are implemented in the core.
        <emphasis>Most are implemented with plugins using Lilikoi</emphasis>.
        Quite literally anything is possible, which is why having a surface level understanding
        is important for
    </p>

    <p>
        Lilikoi is responsible for building <emphasis>containers</emphasis>, each of which
        has a <emphasis>host</emphasis> and <emphasis>entry point</emphasis>, with a set of
        <emphasis>attributes</emphasis> that configure how the container is compiled.
    </p>

    <deflist style="full" collapsible="true">
        <def title="Containers">
            <p>
                Containers are functions that create the host,
                execute all injections/wraps, execute the entry point,
                and then handle the result (casting it and passing it back to the invoker).
            </p>
            <p>
                Containers compile down to <code>Func&lt;TInput, TOutput></code>
                types and can be used as delegates.
            </p>
            <p>
                Containers contain a global <emphasis>Mount</emphasis> object, which
                is given to all attributes and can be used to configure the container.
                In BitMod, this is the global <code>BitMod</code> object.
            </p>
        </def>
        <def title="Host">
            <p>
                Hosts are the classes in which an entry point is contained.
                Hosts allow the entry points to access injected fields
                specified by injection attributes.
            </p>
        </def>
        <def title="Entry Point">
            <p>
                The function that is targeted by the container.
                In BitMod's case, these are event handler methods with the appropriate
                <emphasis>Target</emphasis> attribute.
            </p>
        </def>
    </deflist>

    <chapter id="plugin-basics-attributes" title="Attributes">
        <p>
            Lilikoi provides special attribute types which are used to modify the code
            generated by the Lilikoi compiler.
        </p>
        <deflist style="full" collapsible="true">
            <def title="Injection" default-state="expanded">
                <p>
                    Placed on a field, these attributes are responsible for
                    filling in a single field and disposing of it when the
                    entry point exits.
                </p>
                <p>
                    An example is the <code>SingletonAttribute</code>, which can
                    be used to get items from the global <code>BitMod</code> object.
                </p>
                <code-block lang="c#">
                    [Singleton]
                    private PluginInvoker _invoker;

                    [Singleton]
                    private ILogger _logger;
                </code-block>
            </def>
            <def title="Wrap" default-state="expanded">
                <p>
                    Placed on the entry point, wraps allow a method to be
                    executed before and after the entry point is executed. Wraps
                    can prevent the entry point from running (supplying their own result)
                    or modify the output.
                </p>
                <p>
                    An example is the <code>BitCommandRequireAttribute</code>, which checks
                    if certain conditions are true before executing a command handler, and
                    prevents it from running if they aren't.
                </p>
                <code-block lang="c#">
                    [BitCommand("yes", "Vote yes to the current votekick")]
                    [BitCommandRequire(InGame = true, IsLoggedIn = true)]
                    public async Task OnVoteYes(
                        [CommandSender] ICommandSource source)
                    {
                        return Task.CompletedTask;
                    }
                </code-block>
            </def>
            <def title="Parameters">
                <p>
                    Placed on a parameter in the entry point, parameters fetch values
                    from the input and pass them as a parameter to the function.
                    They are used to prevent code-reuse and simplify entry points.
                </p>
                <note>
                    A wildcard uses parameter attributes under the hood. The parameter is used
                    to produce a value, which is then used by all parameters with a matching
                    type that do not have their own parameter inject.
                </note>
                <p>
                    An example is the <code>RelevantGameserverAttribute</code>, which
                    sees if the event inherits from <code>IGameserverEvent</code> and if so
                    gets the relevant gameserver.
                </p>
                <code-block lang="c#">
                    public async Task DoSomethingWithGameserver(
                        GameserverEventHere ev,
                        [RelevantGameserver] BitServer server,
                    )
                </code-block>
            </def>
            <def title="Mutator">
                <warning>
                    Mutator attributes are different from mutator events!
                </warning>
                <p>
                    Mutators can modify the compiler and add their own wraps,
                    parameter injections, and more. These should only be used
                    by advanced users and those seeking to extend BitMod.
                </p>
            </def>
            <def title="Targets">
                <p>
                    Targets are special mutators. When BitMod loads a plugin,
                    it scans for Target attributes, and if so creates their relevant
                    containers. Targets can instruct BitMod on how they should be
                    called (eg, for a specific event, or using custom event systems).
                </p>
                <p>
                    Targets should be used by advanced users only. For examples, check out
                    the <code>CommandAttribute</code> in the commands plugin.
                </p>
            </def>
        </deflist>
    </chapter>

    <chapter id="plugin-basics-mounts" title="Mounts">
        <p>
            Mounts are what Lilikoi calls type-dictionaries (or feature-dictionaries in ASP.NET).
            Mounts contain objects indexed by their type, and can thus be used to safely store any class
            and retrieve it using generic methods.
        </p>

        <p>
            Mounts are everywhere. The global <code>BitMod</code> class is a mount,
            all events are mounts, and players/gameservers are mounts too.
        </p>

        <p>
            Mounts enable you to store information without having to worry about what
            any other plugin is doing. You won't have to worry about other plugins using
            the same names or structures--each class is owned by you, and is unique to you.
        </p>

        <deflist style="medium" collapsible="true">
            <def title="T? Get<T>()">
                Gets an object of type T in the dictionary,
                if it exists. Returns null otherwise.
            </def>
            <def title="void Store<T>(T obj)">
                Stores (or overwrites) an object in the dictionary.
            </def>
            <def title="bool Has<T>()">
                Returns whether or not the specified
                object is in the dictionary.
            </def>
        </deflist>
    </chapter>

</topic>